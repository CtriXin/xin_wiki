<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ç«æŸ´äººè£…å¤‡å¤§å¸ˆï¼šåœ°ç‰¢å®ˆå«</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
    }

    body {
      background: #1a1a2e;
      overflow: hidden;
      font-family: 'Courier New', monospace;
    }

    #gameCanvas {
      display: block;
      background: linear-gradient(to bottom, #16213e 0%, #0f3460 100%);
    }

    .ui-layer {
      position: absolute;
      pointer-events: none;
    }

    /* èƒŒåŒ…æ ï¼ˆå›¾4é£æ ¼ï¼‰ */
    #inventory {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      background: rgba(139, 69, 19, 0.9);
      padding: 8px;
      border: 3px solid #5d4037;
      border-radius: 8px;
      pointer-events: auto;
    }

    .inv-slot {
      width: 48px;
      height: 48px;
      background: #f5deb3;
      border: 2px solid #8b4513;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      cursor: pointer;
      position: relative;
      transition: transform 0.1s;
    }

    .inv-slot:hover {
      transform: scale(1.1);
    }

    .inv-slot .rarity-border {
      position: absolute;
      inset: 0;
      border: 3px solid #7f8c8d;
      pointer-events: none;
    }

    .inv-slot.equipped .rarity-border {
      border-color: #ffd700;
      box-shadow: 0 0 10px #ffd700;
    }

    /* èŒä¸šåˆ‡æ¢æ ï¼ˆå›¾1é£æ ¼ï¼‰ */
    #classBar {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      pointer-events: auto;
    }

    .class-btn {
      width: 70px;
      height: 70px;
      background: rgba(0, 0, 0, 0.7);
      border: 3px solid #4a5568;
      border-radius: 12px;
      color: white;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      transition: all 0.2s;
    }

    .class-btn.active {
      border-color: #00bfff;
      background: rgba(0, 191, 255, 0.2);
      transform: translateY(-5px);
    }

    .class-icon {
      font-size: 28px;
      margin-bottom: 2px;
    }

    /* èµ„æºæ˜¾ç¤º */
    #resources {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 18px;
      text-shadow: 2px 2px 0 #000;
    }

    /* æ³¢æ¬¡æç¤º */
    #waveInfo {
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      color: #e74c3c;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 2px 2px 0 #000;
      opacity: 0;
      transition: opacity 0.3s;
    }

    /* å‡çº§æç¤º */
    .upgrade-toast {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: #ffd700;
      padding: 20px 40px;
      border: 3px solid #ffd700;
      border-radius: 10px;
      font-size: 24px;
      display: none;
      z-index: 100;
    }
  </style>
  <base target="_blank">
</head>

<body>
  <canvas id="gameCanvas"></canvas>

  <!-- UIå±‚ -->
  <div id="resources">
    <div>ğŸ’ <span id="gems">0</span></div>
    <div>âš”ï¸ å‡»æ€: <span id="kills">0</span></div>
    <div>ğŸŒŠ æ³¢æ¬¡: <span id="wave">1</span></div>
  </div>

  <div id="inventory">
    <div class="inv-slot equipped" data-slot="0" onclick="equipItem(0)">
      <div class="rarity-border" style="border-color: #7f8c8d;"></div>
      <span>ğŸ—¡ï¸</span>
    </div>
    <div class="inv-slot" data-slot="1" onclick="equipItem(1)">
      <div class="rarity-border" style="border-color: #ffd700;"></div>
      <span>ğŸ¹</span>
    </div>
    <div class="inv-slot" data-slot="2" onclick="equipItem(2)">
      <div class="rarity-border" style="border-color: #00bfff;"></div>
      <span>ğŸ”±</span>
    </div>
    <div class="inv-slot" data-slot="3" onclick="equipItem(3)">
      <div class="rarity-border" style="border-color: #9400d3;"></div>
      <span>âš¡</span>
    </div>
  </div>

  <div id="waveInfo">ğŸ§Ÿâ€â™‚ï¸ åƒµå°¸æ¥è¢­ï¼</div>

  <div id="classBar">
    <button class="class-btn active" onclick="switchClass('warrior')">
      <span class="class-icon">ğŸ›¡ï¸</span>
      <span>æˆ˜å£«</span>
    </button>
    <button class="class-btn" onclick="switchClass('archer')">
      <span class="class-icon">ğŸ¹</span>
      <span>å¼“ç®­æ‰‹</span>
    </button>
    <button class="class-btn" onclick="switchClass('mage')">
      <span class="class-icon">ğŸ”®</span>
      <span>æ³•å¸ˆ</span>
    </button>
    <button class="class-btn" onclick="switchClass('assassin')">
      <span class="class-icon">ğŸ—¡ï¸</span>
      <span>åˆºå®¢</span>
    </button>
  </div>

  <div class="upgrade-toast" id="upgradeToast">
    è£…å¤‡å‡çº§ï¼<br>
    <small id="upgradeName">é“å‰‘ â†’ é‡‘å‰‘</small>
  </div>

  <script>
    // æ¸¸æˆé…ç½®ï¼ˆåŸºäºå­©å­çš„æ‰‹ç»˜ï¼‰
    const CONFIG = {
      classes: {
        warrior: { hp: 150, dmg: 15, range: 60, color: '#e74c3c', speed: 2 },
        archer: { hp: 80, dmg: 12, range: 200, color: '#27ae60', speed: 3 },
        mage: { hp: 60, dmg: 25, range: 150, color: '#9b59b6', speed: 2, aoe: true },
        assassin: { hp: 90, dmg: 30, range: 50, color: '#34495e', speed: 5, crit: 0.3 }
      },
      rarities: [
        { name: 'é»‘é“', color: '#7f8c8d', bonus: 1 },
        { name: 'é»„é‡‘', color: '#ffd700', bonus: 1.5 },
        { name: 'é’»çŸ³', color: '#00bfff', bonus: 2.2 },
        { name: 'å²è¯—', color: '#9400d3', bonus: 3.5 }
      ],
      waves: [
        { count: 5, interval: 2000, hp: 30, speed: 0.5 },
        { count: 8, interval: 1800, hp: 50, speed: 0.7 },
        { count: 12, interval: 1500, hp: 80, speed: 0.8 },
        { count: 20, interval: 1200, hp: 100, speed: 1 }
      ]
    };

    // æ¸¸æˆçŠ¶æ€
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let game = {
      width: window.innerWidth,
      height: window.innerHeight,
      gems: 0,
      kills: 0,
      wave: 0,
      currentClass: 'warrior',
      inventory: [
        { type: 'sword', rarity: 0, icon: 'ğŸ—¡ï¸' },
        { type: 'bow', rarity: 1, icon: 'ğŸ¹' },
        { type: 'trident', rarity: 2, icon: 'ğŸ”±' },
        { type: 'staff', rarity: 3, icon: 'âš¡' }
      ],
      equippedSlot: 0,
      enemies: [],
      projectiles: [],
      particles: [],
      base: { x: 100, y: 0, hp: 1000, maxHp: 1000 },
      lastSpawn: 0,
      waveInProgress: false
    };

    // è®¾ç½®ç”»å¸ƒ
    function resize () {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      game.base.y = canvas.height - 150;
    }
    window.addEventListener('resize', resize);
    resize();

    // ç©å®¶å¯¹è±¡ï¼ˆç«æŸ´äººï¼‰
    const player = {
      x: 150,
      y: 0,
      vx: 0,
      vy: 0,
      facing: 1, // 1å³ -1å·¦
      animFrame: 0,
      attacking: false,
      attackCooldown: 0,
      hp: 150,
      maxHp: 150
    };

    function updatePlayer () {
      const cfg = CONFIG.classes[game.currentClass];
      player.maxHp = cfg.hp;
      if (player.hp > player.maxHp) player.hp = player.maxHp;

      player.y = game.base.y - 40;

      // è‡ªåŠ¨å¯»æ•Œ
      let nearest = null;
      let minDist = Infinity;
      game.enemies.forEach(e => {
        const dist = Math.abs(e.x - player.x);
        if (dist < minDist && dist < cfg.range) {
          minDist = dist;
          nearest = e;
        }
      });

      if (nearest) {
        player.facing = nearest.x > player.x ? 1 : -1;
        if (player.attackCooldown <= 0) {
          attack(nearest);
          player.attackCooldown = 30;
        }
      }

      if (player.attackCooldown > 0) player.attackCooldown--;
      player.animFrame++;
    }

    function attack (target) {
      const cfg = CONFIG.classes[game.currentClass];
      const item = game.inventory[game.equippedSlot];
      const rarity = CONFIG.rarities[item.rarity];
      let dmg = cfg.dmg * rarity.bonus;

      // åˆºå®¢æš´å‡»
      if (cfg.crit && Math.random() < cfg.crit) {
        dmg *= 2;
        createFloatingText(target.x, target.y - 30, 'æš´å‡»!', '#e74c3c', 20);
      }

      if (cfg.range > 100) {
        // è¿œç¨‹
        game.projectiles.push({
          x: player.x,
          y: player.y - 30,
          vx: player.facing * 8,
          vy: 0,
          dmg: dmg,
          color: rarity.color,
          type: item.type
        });
      } else {
        // è¿‘æˆ˜
        target.hp -= dmg;
        createParticles(target.x, target.y, rarity.color, 5);
        if (target.hp <= 0) killEnemy(target);
      }

      player.attacking = true;
      setTimeout(() => player.attacking = false, 200);
    }

    // æ•Œäººç”Ÿæˆ
    function spawnEnemy () {
      const wave = CONFIG.waves[Math.min(game.wave, CONFIG.waves.length - 1)];
      game.enemies.push({
        x: canvas.width + 50,
        y: game.base.y - 30,
        hp: wave.hp,
        maxHp: wave.hp,
        speed: wave.speed,
        frozen: 0
      });
    }

    function updateEnemies () {
      const wave = CONFIG.waves[Math.min(game.wave, CONFIG.waves.length - 1)];

      // æ³¢æ¬¡é€»è¾‘
      if (!game.waveInProgress && game.enemies.length === 0) {
        setTimeout(() => {
          game.waveInProgress = true;
          game.wave++;
          document.getElementById('wave').textContent = game.wave;
          showWaveInfo();
          let spawned = 0;
          const interval = setInterval(() => {
            if (spawned >= wave.count) {
              clearInterval(interval);
              game.waveInProgress = false;
              return;
            }
            spawnEnemy();
            spawned++;
          }, wave.interval);
        }, 3000);
      }

      game.enemies = game.enemies.filter(e => {
        if (e.frozen > 0) {
          e.frozen--;
        } else {
          e.x -= e.speed;
        }

        // æ”»å‡»åŸºåœ°
        if (e.x < game.base.x + 80) {
          game.base.hp -= 0.5;
          createParticles(e.x, e.y, '#e74c3c', 2);
          if (game.base.hp <= 0) gameOver();
        }

        return e.x > -50 && e.hp > 0;
      });
    }

    function killEnemy (e) {
      game.kills++;
      game.gems += 10 + (game.wave * 2);
      createParticles(e.x, e.y, '#27ae60', 8);
      createFloatingText(e.x, e.y - 20, '+ğŸ’' + (10 + game.wave * 2), '#00bfff');
      updateUI();

      // å‡çº§æ£€æŸ¥
      checkUpgrade();
    }

    function checkUpgrade () {
      const slot = game.equippedSlot;
      const item = game.inventory[slot];
      const killsNeeded = (item.rarity + 1) * 5;

      if (game.kills % killsNeeded === 0 && item.rarity < 3) {
        item.rarity++;
        const newRarity = CONFIG.rarities[item.rarity];

        // æ›´æ–°UIè¾¹æ¡†é¢œè‰²
        const slotEl = document.querySelector(`[data-slot="${slot}"] .rarity-border`);
        slotEl.style.borderColor = newRarity.color;

        // æ˜¾ç¤ºå‡çº§æç¤º
        const toast = document.getElementById('upgradeToast');
        document.getElementById('upgradeName').textContent =
          `${CONFIG.rarities[item.rarity - 1].name} â†’ ${newRarity.name}`;
        toast.style.display = 'block';
        toast.style.borderColor = newRarity.color;
        setTimeout(() => toast.style.display = 'none', 2000);
      }
    }

    // æŠ•å°„ç‰©
    function updateProjectiles () {
      game.projectiles = game.projectiles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;

        // å‘½ä¸­æ£€æµ‹
        for (let e of game.enemies) {
          if (Math.abs(p.x - e.x) < 30 && Math.abs(p.y - e.y) < 30) {
            e.hp -= p.dmg;
            createParticles(e.x, e.y, p.color, 3);

            // æ³•å¸ˆAOE
            if (game.currentClass === 'mage') {
              game.enemies.forEach(neighbor => {
                if (neighbor !== e && Math.abs(neighbor.x - e.x) < 60) {
                  neighbor.hp -= p.dmg * 0.5;
                  neighbor.frozen = 30; // å†°å†»
                }
              });
            }

            if (e.hp <= 0) killEnemy(e);
            return false;
          }
        }

        return p.x > 0 && p.x < canvas.width;
      });
    }

    // ç²’å­æ•ˆæœ
    function createParticles (x, y, color, count) {
      for (let i = 0; i < count; i++) {
        game.particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 4,
          life: 30,
          color: color
        });
      }
    }

    function updateParticles () {
      game.particles = game.particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        return p.life > 0;
      });
    }

    // ç»˜åˆ¶å‡½æ•°
    function draw () {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // ç»˜åˆ¶åŸºåœ°ï¼ˆå›¾3é£æ ¼ï¼‰
      drawBase();

      // ç»˜åˆ¶ç©å®¶ç«æŸ´äºº
      drawStickman(player.x, player.y, game.currentClass, player.facing);

      // ç»˜åˆ¶æ•Œäººï¼ˆåƒµå°¸ç«æŸ´äººï¼‰
      game.enemies.forEach(e => {
        drawZombie(e.x, e.y, e.hp / e.maxHp);
      });

      // ç»˜åˆ¶æŠ•å°„ç‰©
      game.projectiles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
        ctx.fill();
        // æ‹–å°¾
        ctx.fillStyle = p.color + '40';
        ctx.beginPath();
        ctx.arc(p.x - p.vx * 2, p.y - p.vy * 2, 4, 0, Math.PI * 2);
        ctx.fill();
      });

      // ç»˜åˆ¶ç²’å­
      game.particles.forEach(p => {
        ctx.globalAlpha = p.life / 30;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
      });
      ctx.globalAlpha = 1;

      // ç»˜åˆ¶è¡€æ¡
      drawHealthBars();
    }

    function drawBase () {
      const x = game.base.x;
      const y = game.base.y;

      // ä¸»ä½“
      ctx.fillStyle = '#8d6e63';
      ctx.fillRect(x, y, 80, 60);

      // å±‹é¡¶
      ctx.fillStyle = '#5d4037';
      ctx.beginPath();
      ctx.moveTo(x - 10, y);
      ctx.lineTo(x + 40, y - 40);
      ctx.lineTo(x + 90, y);
      ctx.fill();

      // é—¨
      ctx.fillStyle = '#4e342e';
      ctx.fillRect(x + 30, y + 30, 20, 30);

      // åŸºåœ°è¡€æ¡
      const hpPct = game.base.hp / game.base.maxHp;
      ctx.fillStyle = '#e74c3c';
      ctx.fillRect(x, y - 50, 80, 8);
      ctx.fillStyle = '#27ae60';
      ctx.fillRect(x, y - 50, 80 * hpPct, 8);
      ctx.strokeStyle = '#fff';
      ctx.strokeRect(x, y - 50, 80, 8);
    }

    function drawStickman (x, y, type, facing) {
      ctx.strokeStyle = CONFIG.classes[type].color;
      ctx.lineWidth = 3;
      ctx.lineCap = 'round';

      const bounce = Math.sin(player.animFrame * 0.1) * 3;
      const attackOffset = player.attacking ? facing * 15 : 0;

      // å¤´
      ctx.beginPath();
      ctx.arc(x, y - 50 + bounce, 10, 0, Math.PI * 2);
      ctx.stroke();

      // èº«ä½“
      ctx.beginPath();
      ctx.moveTo(x, y - 40 + bounce);
      ctx.lineTo(x, y - 20 + bounce);
      ctx.stroke();

      // æ‰‹è‡‚ï¼ˆæŒæ­¦å™¨ï¼‰
      const weaponX = x + (facing * 25) + attackOffset;
      ctx.beginPath();
      ctx.moveTo(x, y - 35 + bounce);
      ctx.lineTo(weaponX, y - 30 + bounce);
      ctx.stroke();

      // æ­¦å™¨å›¾æ ‡
      const item = game.inventory[game.equippedSlot];
      ctx.font = '20px Arial';
      ctx.fillText(item.icon, weaponX - 10, y - 25 + bounce);

      // å¦ä¸€åªæ‰‹è‡‚
      ctx.beginPath();
      ctx.moveTo(x, y - 35 + bounce);
      ctx.lineTo(x - (facing * 15), y - 25 + bounce);
      ctx.stroke();

      // è…¿
      ctx.beginPath();
      ctx.moveTo(x, y - 20 + bounce);
      ctx.lineTo(x - 10, y + bounce);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x, y - 20 + bounce);
      ctx.lineTo(x + 10, y + bounce);
      ctx.stroke();
    }

    function drawZombie (x, y, hpPct) {
      ctx.strokeStyle = '#2e7d32';
      ctx.fillStyle = '#d32f2f';
      ctx.lineWidth = 2;

      // å¤´
      ctx.beginPath();
      ctx.arc(x, y - 40, 10, 0, Math.PI * 2);
      ctx.stroke();
      // çœ¼ç›
      ctx.beginPath();
      ctx.arc(x - 3, y - 42, 2, 0, Math.PI * 2);
      ctx.arc(x + 3, y - 42, 2, 0, Math.PI * 2);
      ctx.fill();

      // èº«ä½“
      ctx.beginPath();
      ctx.moveTo(x, y - 30);
      ctx.lineTo(x, y - 10);
      ctx.stroke();

      // æ‰‹è‡‚å‰ä¼¸
      ctx.beginPath();
      ctx.moveTo(x, y - 25);
      ctx.lineTo(x - 20, y - 20);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x, y - 25);
      ctx.lineTo(x + 20, y - 20);
      ctx.stroke();

      // è…¿
      ctx.beginPath();
      ctx.moveTo(x, y - 10);
      ctx.lineTo(x - 8, y + 5);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x, y - 10);
      ctx.lineTo(x + 8, y + 5);
      ctx.stroke();

      // è¡€æ¡
      ctx.fillStyle = '#e74c3c';
      ctx.fillRect(x - 15, y - 60, 30, 4);
      ctx.fillStyle = '#27ae60';
      ctx.fillRect(x - 15, y - 60, 30 * hpPct, 4);
    }

    function drawHealthBars () {
      // ç©å®¶è¡€æ¡
      const cfg = CONFIG.classes[game.currentClass];
      ctx.fillStyle = '#e74c3c';
      ctx.fillRect(player.x - 20, player.y - 70, 40, 6);
      ctx.fillStyle = cfg.color;
      ctx.fillRect(player.x - 20, player.y - 70, 40 * (player.hp / player.maxHp), 6);
    }

    // UI äº¤äº’
    function switchClass (className) {
      game.currentClass = className;
      document.querySelectorAll('.class-btn').forEach(btn => btn.classList.remove('active'));
      event.target.closest('.class-btn').classList.add('active');

      // åˆ‡æ¢å¯¹åº”è£…å¤‡
      const slotMap = { warrior: 0, archer: 1, mage: 2, assassin: 3 };
      equipItem(slotMap[className]);
    }

    function equipItem (slot) {
      game.equippedSlot = slot;
      document.querySelectorAll('.inv-slot').forEach(el => el.classList.remove('equipped'));
      document.querySelector(`[data-slot="${slot}"]`).classList.add('equipped');
    }

    function updateUI () {
      document.getElementById('gems').textContent = game.gems;
      document.getElementById('kills').textContent = game.kills;
    }

    function showWaveInfo () {
      const el = document.getElementById('waveInfo');
      el.style.opacity = 1;
      setTimeout(() => el.style.opacity = 0, 3000);
    }

    function createFloatingText (x, y, text, color, size = 16) {
      const el = document.createElement('div');
      el.style.cssText = `
                position: absolute;
                left: ${x}px;
                top: ${y}px;
                color: ${color};
                font-size: ${size}px;
                font-weight: bold;
                pointer-events: none;
                text-shadow: 2px 2px 0 #000;
                transition: all 1s;
                z-index: 50;
            `;
      el.textContent = text;
      document.body.appendChild(el);

      setTimeout(() => {
        el.style.transform = 'translateY(-50px)';
        el.style.opacity = 0;
      }, 50);
      setTimeout(() => el.remove(), 1000);
    }

    function gameOver () {
      alert(`åŸºåœ°è¢«æ”»ç ´ï¼
å­˜æ´»æ³¢æ¬¡: ${game.wave}
æ€»å‡»æ€: ${game.kills}
è·å¾—é’»çŸ³: ${game.gems}`);
      location.reload();
    }

    // æ¸¸æˆå¾ªç¯
    function loop () {
      updatePlayer();
      updateEnemies();
      updateProjectiles();
      updateParticles();
      draw();
      requestAnimationFrame(loop);
    }

    // ç‚¹å‡»å±å¹•æ”»å‡»ï¼ˆæ‰‹åŠ¨æ¨¡å¼ï¼‰
    canvas.addEventListener('click', (e) => {
      if (player.attackCooldown <= 0) {
        const rect = canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        player.facing = clickX > player.x ? 1 : -1;

        // å¯»æ‰¾ç‚¹å‡»æ–¹å‘çš„æ•Œäºº
        let target = null;
        let minDist = Infinity;
        game.enemies.forEach(en => {
          const dist = Math.abs(en.x - player.x);
          if (dist < minDist && (en.x - player.x) * player.facing > 0) {
            minDist = dist;
            target = en;
          }
        });

        if (target) attack(target);
        player.attackCooldown = 20;
      }
    });

    // å¯åŠ¨
    loop();
    updateUI();

    // è‡ªåŠ¨å›è¡€
    setInterval(() => {
      if (player.hp < player.maxHp) player.hp += 1;
      if (game.base.hp < game.base.maxHp) game.base.hp += 2;
    }, 1000);
  </script>
</body>

</html>